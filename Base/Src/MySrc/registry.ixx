
// VS2022が完全対応するまでモジュールは全面的に使用出来ないものとします

////============================================================================
//// 
//// レジストリクラステンプレート、モジュールインターフェース [registry.ixx]
//// Author : 福田歩希
//// 
////============================================================================
//
////****************************************************
//// モジュール宣言
////****************************************************
//export module registry;
//
////****************************************************
//// レジストリクラステンプレートの定義
////****************************************************
//export template <typename T>
//class CRegistry
//{
//public:
//
//	//****************************************************
//	// special function
//	//****************************************************
//	CRegistry();  // デフォルトコンストラクタ
//	~CRegistry(); // デストラクタ
//
//	//****************************************************
//	// function
//	//****************************************************s
//
//	// 初期化処理
//	// Path      -> データのパス
//	// fpFactory -> データのためのファクトリ関数
//	// fpRelease -> データのためのリリース関数
//	bool Initialize(const std::string& Path, std::function<T(const std::string&)>&& fpFactory, std::function<void(T&)>&& fpRelease);
//	
//	// 終了処理
//	void Finalize();
//
//	// キーを受け取って、保有している物を返す
//	T BindAtKey(const std::string& Key);
//
//	// ランタイム向けのの新規登録
//	bool Register(const std::string& Key, const std::string& Path);
//
//private:
//
//	//****************************************************
//	// data
//	//****************************************************
//	std::function<T(const std::string&)> m_fpFactory; // データのためのファクトリ関数
//	std::function<void(T&)>              m_fpRelease; // データのためのリリース関数
//	std::map<std::string, T>             m_mData;     // キーとデータのマップ
//};
//
////============================================================================
//// デフォルトコンストラクタ
////============================================================================
//template <typename T>
//CRegistry<T>::CRegistry()
//	: m_fpFactory(nullptr)
//	, m_fpRelease(nullptr)
//	, m_mData{}
//{}
//
////============================================================================
//// デストラクタ
////============================================================================
//template <typename T>
//CRegistry<T>::~CRegistry()
//{
//	// 終了処理
//	Finalize();
//}
//
////============================================================================
//// 初期化処理
////============================================================================
//template <typename T>
//bool CRegistry<T>::Initialize(const std::string& Path, std::function<T(const std::string&)>&& fpFactory, std::function<void(T&)>&& fpRelease)
//{
//	// 生成か破棄の関数が無い場合初期化出来ない
//	if (!fpFactory || !fpRelease)
//	{
//		return false;
//	}
//
//	// 受け取った関数をムーブ
//	m_fpFactory = std::move(fpFactory);
//	m_fpRelease = std::move(fpRelease);
//
//	// 指定パスのJSONファイルを展開
//	const JSON& Json = useful::OpenJsonFileMaybeThrow(Path);
//
//	// データ数を確認
//	const decltype(Json["Element"].size()) MaxSize = Json["Element"].size();
//
//	// データの生成を行い、マップに格納する
//	for (int nCntIdx = 0; nCntIdx < MaxSize; ++nCntIdx)
//	{
//		m_mData.insert(std::make_pair(Json["Element"][nCntIdx][0], m_fpFactory(Json["Element"][nCntIdx][1])));
//	}
//
//	return true;
//}
//
////============================================================================
//// 終了処理
////============================================================================
//template <typename T> 
//void CRegistry<T>::Finalize()
//{
//	// 解放用の関数が無い
//	if (m_fpRelease)
//	{
//		std::runtime_error("Kaihouyou Kansu ga Nai");
//	}
//
//	// 事前に受け取っていた関数で全てのデータを解放
//	for (auto& it : m_mData)
//	{
//		m_fpRelease(it.second);
//	}
//
//	// マップをクリア
//	m_mData.clear();
//}
//
////============================================================================
//// キーを受け取って、保有している物を返す
////============================================================================
//template <typename T>
//T CRegistry<T>::BindAtKey(const std::string& Key)
//{
//	// 指定されたキーに対応するデータを探す
//	const decltype(m_mData)::iterator& it = m_mData.find(Key);
//
//	// 見つからなかった場合は例外を投げる
//	if (it == m_mData.end())
//	{
//		throw std::runtime_error("'BindAtKey' was Failed : " + Key);
//	}
//
//	// 見つかった場合は対応するデータを返す
//	return it->second;
//}
//
////============================================================================
//// ランタイム向けのの新規登録
////============================================================================
//template <typename T>
//bool CRegistry<T>::Register(const std::string& Key, const std::string& Path)
//{
//	// 生成用の関数が無い
//	if (m_fpFactory)
//	{
//		std::runtime_error("Seiseiyou Kansu ga Nai");
//	}
//
//	// 指定されたキーに対応するデータを探す
//	const decltype(m_mData)::iterator& it = m_mData.find(Key);
//
//	// 既に登録されている場合は登録出来ない
//	if (it != m_mData.end())
//	{
//		return false;
//	}
//
//	// 新規登録
//	m_mData.insert(std::make_pair(Key, m_fpFactory(Path)));
//
//	// 登録の成功を通知する
//	return true;
//}